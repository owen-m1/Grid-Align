(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["GridAlign"] = factory();
	else
		root["GridAlign"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./gridAlign.js":
/*!**********************!*\
  !*** ./gridAlign.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


let options = {
  animation: 1000,
  randomizeRows: true
};

function alignGrid(el, userOptions) {
  userOptions && mergeObj(options, userOptions);
  let grid = [[]],
      elRect = el.getBoundingClientRect(),
      lengthPropety = 'width',
      oppLengthProperty = 'height',
      children = Array.from(el.children),
      elLength = elRect[lengthPropety];
  let animateRectsBefore = children.map(a => {
    return {
      rect: a.getBoundingClientRect(),
      el: a
    };
  });
  let rows = Math.floor(children[children.length - 1].getBoundingClientRect().bottom / children[0].getBoundingClientRect()[oppLengthProperty]); // Make new 2D array

  let newGrid = [];

  for (let i = 0; i < rows; i++) {
    newGrid.push([]);
  }

  let pool = children.map((el, i) => {
    return {
      rect: el.getBoundingClientRect(),
      el,
      originalIndex: i
    };
  });

  for (let row = 0; row < rows; row++) {
    let widthLeft = elLength;

    while (true) {
      let currentLastInRow = 0;

      for (let i in newGrid[row]) {
        currentLastInRow += newGrid[row][i].rect.width;
      }

      let differencesSorted = pool.sort(function (a, b) {
        if (!a || !b) return;
        let aPotentialEnd = currentLastInRow + a.el.getBoundingClientRect()[lengthPropety],
            bPotentialEnd = currentLastInRow + b.el.getBoundingClientRect()[lengthPropety];
        a.difference = elLength - aPotentialEnd;
        b.difference = elLength - bPotentialEnd;
        return a.difference - b.difference;
      });
      let chosenEl = differencesSorted[0];
      if (!chosenEl) break;
      let currDiff = chosenEl.difference;
      let chosenIndex = 0;

      while (currDiff < 0) {
        chosenIndex++;

        if (chosenIndex > differencesSorted.length - 1) {
          break;
        }

        chosenEl = differencesSorted[chosenIndex];
        currDiff = chosenEl.difference;
      } // If overflowing, new row


      if (currDiff < 0) {
        break;
      }

      pool.splice(pool.indexOf(chosenEl), 1);
      widthLeft -= chosenEl.el.getBoundingClientRect()[lengthPropety];
      newGrid[row].push(chosenEl);
    }

    newGrid[row] = newGrid[row].sort((a, b) => a.originalIndex - b.originalIndex);
  }

  if (options.randomizeRows) {
    let rowsExcludingLast = newGrid.slice(0, newGrid.length - 1);
    newGrid = [newGrid[newGrid.length - 1]];
    newGrid = [...shuffle(rowsExcludingLast), ...newGrid];
  }

  while (el.hasChildNodes()) {
    el.removeChild(el.lastChild);
  } // Reconstruct


  for (let i in newGrid) {
    for (let n in newGrid[i]) {
      el.appendChild(newGrid[i][n].el);
    }
  } // Animation


  for (let i in newGrid) {
    for (let n in newGrid[i]) {
      animate(animateRectsBefore.find(a => a.el === newGrid[i][n].el).rect, newGrid[i][n].el);
    }
  }
}

function mergeObj(to, from) {
  for (let prop in from) {
    to[prop] = from[prop];
  }
}

function _css(el, prop, val) {
  let style = el && el.style;

  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }

      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }

      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}

let repaint;

function animate(prevRect, target) {
  let ms = options.animation;
  if (target.animated) return;

  if (ms) {
    let currentRect = target.getBoundingClientRect();

    if (prevRect.nodeType === 1) {
      prevRect = prevRect.getBoundingClientRect();
    } // Check if actually moving position


    if (prevRect.left + prevRect.width / 2 !== currentRect.left + currentRect.width / 2 || prevRect.top + prevRect.height / 2 !== currentRect.top + currentRect.height / 2) {
      _css(target, 'transition', 'none');

      _css(target, 'transform', 'translate(' + (prevRect.left - currentRect.left) + 'px,' + (prevRect.top - currentRect.top) + 'px)');

      repaint = target.offsetWidth;

      _css(target, 'transition', 'transform ' + ms + 'ms');

      _css(target, 'transform', 'translate(0,0)');
    }

    typeof target.animated === 'number' && clearTimeout(target.animated);
    target.animated = setTimeout(function () {
      _css(target, 'transition', '');

      _css(target, 'transform', '');

      target.animated = false;
    }, ms);
  }
}

function shuffle(array) {
  let counter = array.length - 1; // While there are elements in the array

  while (counter > 0) {
    // Pick a random index
    let index = Math.floor(Math.random() * counter); // Decrease counter by 1

    counter--; // And swap the last element with it

    let temp = array[counter];
    array[counter] = array[index];
    array[index] = temp;
  }

  return array;
}

module.exports = alignGrid;

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./gridAlign.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./gridAlign.js */"./gridAlign.js");


/***/ })

/******/ });
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9HcmlkQWxpZ24vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovL0dyaWRBbGlnbi93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9HcmlkQWxpZ24vLi9ncmlkQWxpZ24uanMiXSwibmFtZXMiOlsib3B0aW9ucyIsImFuaW1hdGlvbiIsInJhbmRvbWl6ZVJvd3MiLCJhbGlnbkdyaWQiLCJlbCIsInVzZXJPcHRpb25zIiwibWVyZ2VPYmoiLCJncmlkIiwiZWxSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibGVuZ3RoUHJvcGV0eSIsIm9wcExlbmd0aFByb3BlcnR5IiwiY2hpbGRyZW4iLCJBcnJheSIsImZyb20iLCJlbExlbmd0aCIsImFuaW1hdGVSZWN0c0JlZm9yZSIsIm1hcCIsImEiLCJyZWN0Iiwicm93cyIsIk1hdGgiLCJmbG9vciIsImxlbmd0aCIsImJvdHRvbSIsIm5ld0dyaWQiLCJpIiwicHVzaCIsInBvb2wiLCJvcmlnaW5hbEluZGV4Iiwicm93Iiwid2lkdGhMZWZ0IiwiY3VycmVudExhc3RJblJvdyIsIndpZHRoIiwiZGlmZmVyZW5jZXNTb3J0ZWQiLCJzb3J0IiwiYiIsImFQb3RlbnRpYWxFbmQiLCJiUG90ZW50aWFsRW5kIiwiZGlmZmVyZW5jZSIsImNob3NlbkVsIiwiY3VyckRpZmYiLCJjaG9zZW5JbmRleCIsInNwbGljZSIsImluZGV4T2YiLCJyb3dzRXhjbHVkaW5nTGFzdCIsInNsaWNlIiwic2h1ZmZsZSIsImhhc0NoaWxkTm9kZXMiLCJyZW1vdmVDaGlsZCIsImxhc3RDaGlsZCIsIm4iLCJhcHBlbmRDaGlsZCIsImFuaW1hdGUiLCJmaW5kIiwidG8iLCJwcm9wIiwiX2NzcyIsInZhbCIsInN0eWxlIiwiZG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJyZXBhaW50IiwicHJldlJlY3QiLCJ0YXJnZXQiLCJtcyIsImFuaW1hdGVkIiwiY3VycmVudFJlY3QiLCJub2RlVHlwZSIsImxlZnQiLCJ0b3AiLCJoZWlnaHQiLCJvZmZzZXRXaWR0aCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJhcnJheSIsImNvdW50ZXIiLCJpbmRleCIsInJhbmRvbSIsInRlbXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQTBDLGdDQUFnQztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUF3RCxrQkFBa0I7QUFDMUU7QUFDQSx5REFBaUQsY0FBYztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQXlDLGlDQUFpQztBQUMxRSx3SEFBZ0gsbUJBQW1CLEVBQUU7QUFDckk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7O0FBR0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xGYTs7QUFFYixJQUFJQSxPQUFPLEdBQUc7QUFDYkMsV0FBUyxFQUFFLElBREU7QUFFYkMsZUFBYSxFQUFFO0FBRkYsQ0FBZDs7QUFLQSxTQUFTQyxTQUFULENBQW1CQyxFQUFuQixFQUF1QkMsV0FBdkIsRUFBb0M7QUFDbkNBLGFBQVcsSUFBSUMsUUFBUSxDQUFDTixPQUFELEVBQVVLLFdBQVYsQ0FBdkI7QUFDQSxNQUFJRSxJQUFJLEdBQUcsQ0FBQyxFQUFELENBQVg7QUFBQSxNQUNDQyxNQUFNLEdBQUdKLEVBQUUsQ0FBQ0sscUJBQUgsRUFEVjtBQUFBLE1BRUNDLGFBQWEsR0FBRyxPQUZqQjtBQUFBLE1BR0NDLGlCQUFpQixHQUFHLFFBSHJCO0FBQUEsTUFJQ0MsUUFBUSxHQUFHQyxLQUFLLENBQUNDLElBQU4sQ0FBV1YsRUFBRSxDQUFDUSxRQUFkLENBSlo7QUFBQSxNQUtDRyxRQUFRLEdBQUdQLE1BQU0sQ0FBQ0UsYUFBRCxDQUxsQjtBQVFBLE1BQUlNLGtCQUFrQixHQUFHSixRQUFRLENBQUNLLEdBQVQsQ0FBYUMsQ0FBQyxJQUFJO0FBQzFDLFdBQU87QUFDTkMsVUFBSSxFQUFFRCxDQUFDLENBQUNULHFCQUFGLEVBREE7QUFFTkwsUUFBRSxFQUFFYztBQUZFLEtBQVA7QUFJQSxHQUx3QixDQUF6QjtBQU9BLE1BQUlFLElBQUksR0FBR0MsSUFBSSxDQUFDQyxLQUFMLENBQVdWLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDVyxNQUFULEdBQWtCLENBQW5CLENBQVIsQ0FBOEJkLHFCQUE5QixHQUFzRGUsTUFBdEQsR0FBK0RaLFFBQVEsQ0FBQyxDQUFELENBQVIsQ0FBWUgscUJBQVosR0FBb0NFLGlCQUFwQyxDQUExRSxDQUFYLENBakJtQyxDQW9CbkM7O0FBQ0EsTUFBSWMsT0FBTyxHQUFHLEVBQWQ7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHTixJQUFwQixFQUEwQk0sQ0FBQyxFQUEzQixFQUErQjtBQUM5QkQsV0FBTyxDQUFDRSxJQUFSLENBQWEsRUFBYjtBQUNBOztBQUdELE1BQUlDLElBQUksR0FBR2hCLFFBQVEsQ0FBQ0ssR0FBVCxDQUFhLENBQUNiLEVBQUQsRUFBS3NCLENBQUwsS0FBVztBQUNsQyxXQUFPO0FBQ05QLFVBQUksRUFBRWYsRUFBRSxDQUFDSyxxQkFBSCxFQURBO0FBRU5MLFFBRk07QUFHTnlCLG1CQUFhLEVBQUVIO0FBSFQsS0FBUDtBQUtBLEdBTlUsQ0FBWDs7QUFTQSxPQUFLLElBQUlJLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdWLElBQXhCLEVBQThCVSxHQUFHLEVBQWpDLEVBQXFDO0FBQ3BDLFFBQUlDLFNBQVMsR0FBR2hCLFFBQWhCOztBQUdBLFdBQU8sSUFBUCxFQUFhO0FBQ1osVUFBSWlCLGdCQUFnQixHQUFHLENBQXZCOztBQUNBLFdBQUssSUFBSU4sQ0FBVCxJQUFjRCxPQUFPLENBQUNLLEdBQUQsQ0FBckIsRUFBNEI7QUFDM0JFLHdCQUFnQixJQUFJUCxPQUFPLENBQUNLLEdBQUQsQ0FBUCxDQUFhSixDQUFiLEVBQWdCUCxJQUFoQixDQUFxQmMsS0FBekM7QUFDQTs7QUFFRCxVQUFJQyxpQkFBaUIsR0FBR04sSUFBSSxDQUFDTyxJQUFMLENBQVUsVUFBU2pCLENBQVQsRUFBWWtCLENBQVosRUFBZTtBQUNoRCxZQUFJLENBQUNsQixDQUFELElBQU0sQ0FBQ2tCLENBQVgsRUFBYztBQUVkLFlBQUlDLGFBQWEsR0FBR0wsZ0JBQWdCLEdBQUdkLENBQUMsQ0FBQ2QsRUFBRixDQUFLSyxxQkFBTCxHQUE2QkMsYUFBN0IsQ0FBdkM7QUFBQSxZQUNDNEIsYUFBYSxHQUFHTixnQkFBZ0IsR0FBR0ksQ0FBQyxDQUFDaEMsRUFBRixDQUFLSyxxQkFBTCxHQUE2QkMsYUFBN0IsQ0FEcEM7QUFJQVEsU0FBQyxDQUFDcUIsVUFBRixHQUFnQnhCLFFBQVEsR0FBR3NCLGFBQTNCO0FBQ0FELFNBQUMsQ0FBQ0csVUFBRixHQUFnQnhCLFFBQVEsR0FBR3VCLGFBQTNCO0FBRUEsZUFBT3BCLENBQUMsQ0FBQ3FCLFVBQUYsR0FBZUgsQ0FBQyxDQUFDRyxVQUF4QjtBQUNBLE9BWHVCLENBQXhCO0FBY0EsVUFBSUMsUUFBUSxHQUFHTixpQkFBaUIsQ0FBQyxDQUFELENBQWhDO0FBQ0EsVUFBSSxDQUFDTSxRQUFMLEVBQWU7QUFFZixVQUFJQyxRQUFRLEdBQUdELFFBQVEsQ0FBQ0QsVUFBeEI7QUFDQSxVQUFJRyxXQUFXLEdBQUcsQ0FBbEI7O0FBRUEsYUFBT0QsUUFBUSxHQUFHLENBQWxCLEVBQXFCO0FBQ3BCQyxtQkFBVzs7QUFDWCxZQUFJQSxXQUFXLEdBQUdSLGlCQUFpQixDQUFDWCxNQUFsQixHQUEyQixDQUE3QyxFQUFnRDtBQUMvQztBQUNBOztBQUNEaUIsZ0JBQVEsR0FBR04saUJBQWlCLENBQUNRLFdBQUQsQ0FBNUI7QUFDQUQsZ0JBQVEsR0FBR0QsUUFBUSxDQUFDRCxVQUFwQjtBQUNBLE9BakNXLENBbUNaOzs7QUFDQSxVQUFJRSxRQUFRLEdBQUcsQ0FBZixFQUFrQjtBQUNqQjtBQUNBOztBQUdEYixVQUFJLENBQUNlLE1BQUwsQ0FBWWYsSUFBSSxDQUFDZ0IsT0FBTCxDQUFhSixRQUFiLENBQVosRUFBb0MsQ0FBcEM7QUFFQVQsZUFBUyxJQUFJUyxRQUFRLENBQUNwQyxFQUFULENBQVlLLHFCQUFaLEdBQW9DQyxhQUFwQyxDQUFiO0FBRUFlLGFBQU8sQ0FBQ0ssR0FBRCxDQUFQLENBQWFILElBQWIsQ0FBa0JhLFFBQWxCO0FBQ0E7O0FBQ0RmLFdBQU8sQ0FBQ0ssR0FBRCxDQUFQLEdBQWVMLE9BQU8sQ0FBQ0ssR0FBRCxDQUFQLENBQWFLLElBQWIsQ0FBa0IsQ0FBQ2pCLENBQUQsRUFBSWtCLENBQUosS0FBVWxCLENBQUMsQ0FBQ1csYUFBRixHQUFrQk8sQ0FBQyxDQUFDUCxhQUFoRCxDQUFmO0FBQ0E7O0FBQ0QsTUFBSTdCLE9BQU8sQ0FBQ0UsYUFBWixFQUEyQjtBQUMxQixRQUFJMkMsaUJBQWlCLEdBQUdwQixPQUFPLENBQUNxQixLQUFSLENBQWMsQ0FBZCxFQUFpQnJCLE9BQU8sQ0FBQ0YsTUFBUixHQUFpQixDQUFsQyxDQUF4QjtBQUNBRSxXQUFPLEdBQUcsQ0FBQ0EsT0FBTyxDQUFDQSxPQUFPLENBQUNGLE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUixDQUFWO0FBRUFFLFdBQU8sR0FBRyxDQUFDLEdBQUdzQixPQUFPLENBQUNGLGlCQUFELENBQVgsRUFBZ0MsR0FBR3BCLE9BQW5DLENBQVY7QUFDQTs7QUFFRCxTQUFPckIsRUFBRSxDQUFDNEMsYUFBSCxFQUFQLEVBQTJCO0FBQzFCNUMsTUFBRSxDQUFDNkMsV0FBSCxDQUFlN0MsRUFBRSxDQUFDOEMsU0FBbEI7QUFDQSxHQWxHa0MsQ0FvR25DOzs7QUFDQSxPQUFLLElBQUl4QixDQUFULElBQWNELE9BQWQsRUFBdUI7QUFDdEIsU0FBSyxJQUFJMEIsQ0FBVCxJQUFjMUIsT0FBTyxDQUFDQyxDQUFELENBQXJCLEVBQTBCO0FBQ3pCdEIsUUFBRSxDQUFDZ0QsV0FBSCxDQUFlM0IsT0FBTyxDQUFDQyxDQUFELENBQVAsQ0FBV3lCLENBQVgsRUFBYy9DLEVBQTdCO0FBQ0E7QUFDRCxHQXpHa0MsQ0EyR25DOzs7QUFDQSxPQUFLLElBQUlzQixDQUFULElBQWNELE9BQWQsRUFBdUI7QUFDdEIsU0FBSyxJQUFJMEIsQ0FBVCxJQUFjMUIsT0FBTyxDQUFDQyxDQUFELENBQXJCLEVBQTBCO0FBQ3pCMkIsYUFBTyxDQUFDckMsa0JBQWtCLENBQUNzQyxJQUFuQixDQUF3QnBDLENBQUMsSUFBSUEsQ0FBQyxDQUFDZCxFQUFGLEtBQVNxQixPQUFPLENBQUNDLENBQUQsQ0FBUCxDQUFXeUIsQ0FBWCxFQUFjL0MsRUFBcEQsRUFBd0RlLElBQXpELEVBQStETSxPQUFPLENBQUNDLENBQUQsQ0FBUCxDQUFXeUIsQ0FBWCxFQUFjL0MsRUFBN0UsQ0FBUDtBQUNBO0FBQ0Q7QUFDRDs7QUFJRCxTQUFTRSxRQUFULENBQWtCaUQsRUFBbEIsRUFBc0J6QyxJQUF0QixFQUE0QjtBQUMzQixPQUFLLElBQUkwQyxJQUFULElBQWlCMUMsSUFBakIsRUFBdUI7QUFDdEJ5QyxNQUFFLENBQUNDLElBQUQsQ0FBRixHQUFXMUMsSUFBSSxDQUFDMEMsSUFBRCxDQUFmO0FBQ0E7QUFDRDs7QUFHRCxTQUFTQyxJQUFULENBQWNyRCxFQUFkLEVBQWtCb0QsSUFBbEIsRUFBd0JFLEdBQXhCLEVBQTZCO0FBQzVCLE1BQUlDLEtBQUssR0FBR3ZELEVBQUUsSUFBSUEsRUFBRSxDQUFDdUQsS0FBckI7O0FBRUEsTUFBSUEsS0FBSixFQUFXO0FBQ1YsUUFBSUQsR0FBRyxLQUFLLEtBQUssQ0FBakIsRUFBb0I7QUFDbkIsVUFBSUUsUUFBUSxDQUFDQyxXQUFULElBQXdCRCxRQUFRLENBQUNDLFdBQVQsQ0FBcUJDLGdCQUFqRCxFQUFtRTtBQUNsRUosV0FBRyxHQUFHRSxRQUFRLENBQUNDLFdBQVQsQ0FBcUJDLGdCQUFyQixDQUFzQzFELEVBQXRDLEVBQTBDLEVBQTFDLENBQU47QUFDQSxPQUZELE1BR0ssSUFBSUEsRUFBRSxDQUFDMkQsWUFBUCxFQUFxQjtBQUN6QkwsV0FBRyxHQUFHdEQsRUFBRSxDQUFDMkQsWUFBVDtBQUNBOztBQUVELGFBQU9QLElBQUksS0FBSyxLQUFLLENBQWQsR0FBa0JFLEdBQWxCLEdBQXdCQSxHQUFHLENBQUNGLElBQUQsQ0FBbEM7QUFDQSxLQVRELE1BVUs7QUFDSixVQUFJLEVBQUVBLElBQUksSUFBSUcsS0FBVixLQUFvQkgsSUFBSSxDQUFDWixPQUFMLENBQWEsUUFBYixNQUEyQixDQUFDLENBQXBELEVBQXVEO0FBQ3REWSxZQUFJLEdBQUcsYUFBYUEsSUFBcEI7QUFDQTs7QUFFREcsV0FBSyxDQUFDSCxJQUFELENBQUwsR0FBY0UsR0FBRyxJQUFJLE9BQU9BLEdBQVAsS0FBZSxRQUFmLEdBQTBCLEVBQTFCLEdBQStCLElBQW5DLENBQWpCO0FBQ0E7QUFDRDtBQUNEOztBQUVELElBQUlNLE9BQUo7O0FBQ0EsU0FBU1gsT0FBVCxDQUFpQlksUUFBakIsRUFBMkJDLE1BQTNCLEVBQW1DO0FBQ2xDLE1BQUlDLEVBQUUsR0FBR25FLE9BQU8sQ0FBQ0MsU0FBakI7QUFDQSxNQUFJaUUsTUFBTSxDQUFDRSxRQUFYLEVBQXFCOztBQUVyQixNQUFJRCxFQUFKLEVBQVE7QUFDUCxRQUFJRSxXQUFXLEdBQUdILE1BQU0sQ0FBQ3pELHFCQUFQLEVBQWxCOztBQUVBLFFBQUl3RCxRQUFRLENBQUNLLFFBQVQsS0FBc0IsQ0FBMUIsRUFBNkI7QUFDNUJMLGNBQVEsR0FBR0EsUUFBUSxDQUFDeEQscUJBQVQsRUFBWDtBQUNBLEtBTE0sQ0FPUDs7O0FBQ0EsUUFBS3dELFFBQVEsQ0FBQ00sSUFBVCxHQUFnQk4sUUFBUSxDQUFDaEMsS0FBVCxHQUFpQixDQUFsQyxLQUEwQ29DLFdBQVcsQ0FBQ0UsSUFBWixHQUFtQkYsV0FBVyxDQUFDcEMsS0FBWixHQUFvQixDQUFqRixJQUNDZ0MsUUFBUSxDQUFDTyxHQUFULEdBQWVQLFFBQVEsQ0FBQ1EsTUFBVCxHQUFrQixDQUFsQyxLQUEwQ0osV0FBVyxDQUFDRyxHQUFaLEdBQWtCSCxXQUFXLENBQUNJLE1BQVosR0FBcUIsQ0FEckYsRUFFRTtBQUNEaEIsVUFBSSxDQUFDUyxNQUFELEVBQVMsWUFBVCxFQUF1QixNQUF2QixDQUFKOztBQUNBVCxVQUFJLENBQUNTLE1BQUQsRUFBUyxXQUFULEVBQXNCLGdCQUN0QkQsUUFBUSxDQUFDTSxJQUFULEdBQWdCRixXQUFXLENBQUNFLElBRE4sSUFDYyxLQURkLElBRXRCTixRQUFRLENBQUNPLEdBQVQsR0FBZUgsV0FBVyxDQUFDRyxHQUZMLElBRVksS0FGbEMsQ0FBSjs7QUFJQVIsYUFBTyxHQUFHRSxNQUFNLENBQUNRLFdBQWpCOztBQUNBakIsVUFBSSxDQUFDUyxNQUFELEVBQVMsWUFBVCxFQUF1QixlQUFlQyxFQUFmLEdBQW9CLElBQTNDLENBQUo7O0FBQ0FWLFVBQUksQ0FBQ1MsTUFBRCxFQUFTLFdBQVQsRUFBc0IsZ0JBQXRCLENBQUo7QUFDQTs7QUFFQSxXQUFPQSxNQUFNLENBQUNFLFFBQWQsS0FBMkIsUUFBNUIsSUFBeUNPLFlBQVksQ0FBQ1QsTUFBTSxDQUFDRSxRQUFSLENBQXJEO0FBQ0FGLFVBQU0sQ0FBQ0UsUUFBUCxHQUFrQlEsVUFBVSxDQUFDLFlBQVk7QUFDeENuQixVQUFJLENBQUNTLE1BQUQsRUFBUyxZQUFULEVBQXVCLEVBQXZCLENBQUo7O0FBQ0FULFVBQUksQ0FBQ1MsTUFBRCxFQUFTLFdBQVQsRUFBc0IsRUFBdEIsQ0FBSjs7QUFDQUEsWUFBTSxDQUFDRSxRQUFQLEdBQWtCLEtBQWxCO0FBQ0EsS0FKMkIsRUFJekJELEVBSnlCLENBQTVCO0FBS0E7QUFDRDs7QUFJRCxTQUFTcEIsT0FBVCxDQUFpQjhCLEtBQWpCLEVBQXdCO0FBQ3BCLE1BQUlDLE9BQU8sR0FBR0QsS0FBSyxDQUFDdEQsTUFBTixHQUFlLENBQTdCLENBRG9CLENBR3BCOztBQUNBLFNBQU91RCxPQUFPLEdBQUcsQ0FBakIsRUFBb0I7QUFDaEI7QUFDQSxRQUFJQyxLQUFLLEdBQUcxRCxJQUFJLENBQUNDLEtBQUwsQ0FBV0QsSUFBSSxDQUFDMkQsTUFBTCxLQUFnQkYsT0FBM0IsQ0FBWixDQUZnQixDQUloQjs7QUFDQUEsV0FBTyxHQUxTLENBT2hCOztBQUNBLFFBQUlHLElBQUksR0FBR0osS0FBSyxDQUFDQyxPQUFELENBQWhCO0FBQ0FELFNBQUssQ0FBQ0MsT0FBRCxDQUFMLEdBQWlCRCxLQUFLLENBQUNFLEtBQUQsQ0FBdEI7QUFDQUYsU0FBSyxDQUFDRSxLQUFELENBQUwsR0FBZUUsSUFBZjtBQUNIOztBQUVELFNBQU9KLEtBQVA7QUFDSDs7QUFFREssTUFBTSxDQUFDQyxPQUFQLEdBQWlCaEYsU0FBakIsQyIsImZpbGUiOiJncmlkQWxpZ24ubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiR3JpZEFsaWduXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIkdyaWRBbGlnblwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gIiwiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5sZXQgb3B0aW9ucyA9IHtcclxuXHRhbmltYXRpb246IDEwMDAsXHJcblx0cmFuZG9taXplUm93czogdHJ1ZVxyXG59O1xyXG5cclxuZnVuY3Rpb24gYWxpZ25HcmlkKGVsLCB1c2VyT3B0aW9ucykge1xyXG5cdHVzZXJPcHRpb25zICYmIG1lcmdlT2JqKG9wdGlvbnMsIHVzZXJPcHRpb25zKTtcclxuXHRsZXQgZ3JpZCA9IFtbXV0sXHJcblx0XHRlbFJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuXHRcdGxlbmd0aFByb3BldHkgPSAnd2lkdGgnLFxyXG5cdFx0b3BwTGVuZ3RoUHJvcGVydHkgPSAnaGVpZ2h0JyxcclxuXHRcdGNoaWxkcmVuID0gQXJyYXkuZnJvbShlbC5jaGlsZHJlbiksXHJcblx0XHRlbExlbmd0aCA9IGVsUmVjdFtsZW5ndGhQcm9wZXR5XTtcclxuXHJcblxyXG5cdGxldCBhbmltYXRlUmVjdHNCZWZvcmUgPSBjaGlsZHJlbi5tYXAoYSA9PiB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRyZWN0OiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxyXG5cdFx0XHRlbDogYVxyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0bGV0IHJvd3MgPSBNYXRoLmZsb29yKGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSAvIGNoaWxkcmVuWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW29wcExlbmd0aFByb3BlcnR5XSk7XHJcblxyXG5cclxuXHQvLyBNYWtlIG5ldyAyRCBhcnJheVxyXG5cdGxldCBuZXdHcmlkID0gW107XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcclxuXHRcdG5ld0dyaWQucHVzaChbXSk7XHJcblx0fVxyXG5cclxuXHJcblx0bGV0IHBvb2wgPSBjaGlsZHJlbi5tYXAoKGVsLCBpKSA9PiB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRyZWN0OiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuXHRcdFx0ZWwsXHJcblx0XHRcdG9yaWdpbmFsSW5kZXg6IGlcclxuXHRcdH07XHJcblx0fSk7XHJcblxyXG5cclxuXHRmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dzOyByb3crKykge1xyXG5cdFx0bGV0IHdpZHRoTGVmdCA9IGVsTGVuZ3RoO1xyXG5cclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRsZXQgY3VycmVudExhc3RJblJvdyA9IDA7XHJcblx0XHRcdGZvciAobGV0IGkgaW4gbmV3R3JpZFtyb3ddKSB7XHJcblx0XHRcdFx0Y3VycmVudExhc3RJblJvdyArPSBuZXdHcmlkW3Jvd11baV0ucmVjdC53aWR0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGV0IGRpZmZlcmVuY2VzU29ydGVkID0gcG9vbC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcclxuXHRcdFx0XHRpZiAoIWEgfHwgIWIpIHJldHVybjtcclxuXHJcblx0XHRcdFx0bGV0IGFQb3RlbnRpYWxFbmQgPSBjdXJyZW50TGFzdEluUm93ICsgYS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtsZW5ndGhQcm9wZXR5XSxcclxuXHRcdFx0XHRcdGJQb3RlbnRpYWxFbmQgPSBjdXJyZW50TGFzdEluUm93ICsgYi5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtsZW5ndGhQcm9wZXR5XTtcclxuXHJcblxyXG5cdFx0XHRcdGEuZGlmZmVyZW5jZSA9IChlbExlbmd0aCAtIGFQb3RlbnRpYWxFbmQpO1xyXG5cdFx0XHRcdGIuZGlmZmVyZW5jZSA9IChlbExlbmd0aCAtIGJQb3RlbnRpYWxFbmQpO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gYS5kaWZmZXJlbmNlIC0gYi5kaWZmZXJlbmNlO1xyXG5cdFx0XHR9KTtcclxuXHJcblxyXG5cdFx0XHRsZXQgY2hvc2VuRWwgPSBkaWZmZXJlbmNlc1NvcnRlZFswXTtcclxuXHRcdFx0aWYgKCFjaG9zZW5FbCkgYnJlYWs7XHJcblx0XHRcdFxyXG5cdFx0XHRsZXQgY3VyckRpZmYgPSBjaG9zZW5FbC5kaWZmZXJlbmNlO1xyXG5cdFx0XHRsZXQgY2hvc2VuSW5kZXggPSAwO1xyXG5cclxuXHRcdFx0d2hpbGUgKGN1cnJEaWZmIDwgMCkge1xyXG5cdFx0XHRcdGNob3NlbkluZGV4Kys7XHJcblx0XHRcdFx0aWYgKGNob3NlbkluZGV4ID4gZGlmZmVyZW5jZXNTb3J0ZWQubGVuZ3RoIC0gMSkge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNob3NlbkVsID0gZGlmZmVyZW5jZXNTb3J0ZWRbY2hvc2VuSW5kZXhdO1xyXG5cdFx0XHRcdGN1cnJEaWZmID0gY2hvc2VuRWwuZGlmZmVyZW5jZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gSWYgb3ZlcmZsb3dpbmcsIG5ldyByb3dcclxuXHRcdFx0aWYgKGN1cnJEaWZmIDwgMCkge1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0cG9vbC5zcGxpY2UocG9vbC5pbmRleE9mKGNob3NlbkVsKSwgMSk7XHJcblxyXG5cdFx0XHR3aWR0aExlZnQgLT0gY2hvc2VuRWwuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbbGVuZ3RoUHJvcGV0eV07XHJcblxyXG5cdFx0XHRuZXdHcmlkW3Jvd10ucHVzaChjaG9zZW5FbCk7XHJcblx0XHR9XHJcblx0XHRuZXdHcmlkW3Jvd10gPSBuZXdHcmlkW3Jvd10uc29ydCgoYSwgYikgPT4gYS5vcmlnaW5hbEluZGV4IC0gYi5vcmlnaW5hbEluZGV4KTtcclxuXHR9XHJcblx0aWYgKG9wdGlvbnMucmFuZG9taXplUm93cykge1xyXG5cdFx0bGV0IHJvd3NFeGNsdWRpbmdMYXN0ID0gbmV3R3JpZC5zbGljZSgwLCBuZXdHcmlkLmxlbmd0aCAtIDEpO1xyXG5cdFx0bmV3R3JpZCA9IFtuZXdHcmlkW25ld0dyaWQubGVuZ3RoIC0gMV1dO1xyXG5cclxuXHRcdG5ld0dyaWQgPSBbLi4uc2h1ZmZsZShyb3dzRXhjbHVkaW5nTGFzdCksIC4uLm5ld0dyaWRdO1xyXG5cdH1cclxuXHJcblx0d2hpbGUgKGVsLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0ZWwucmVtb3ZlQ2hpbGQoZWwubGFzdENoaWxkKTtcclxuXHR9XHJcblxyXG5cdC8vIFJlY29uc3RydWN0XHJcblx0Zm9yIChsZXQgaSBpbiBuZXdHcmlkKSB7XHJcblx0XHRmb3IgKGxldCBuIGluIG5ld0dyaWRbaV0pIHtcclxuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQobmV3R3JpZFtpXVtuXS5lbCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBBbmltYXRpb25cclxuXHRmb3IgKGxldCBpIGluIG5ld0dyaWQpIHtcclxuXHRcdGZvciAobGV0IG4gaW4gbmV3R3JpZFtpXSkge1xyXG5cdFx0XHRhbmltYXRlKGFuaW1hdGVSZWN0c0JlZm9yZS5maW5kKGEgPT4gYS5lbCA9PT0gbmV3R3JpZFtpXVtuXS5lbCkucmVjdCwgbmV3R3JpZFtpXVtuXS5lbCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIG1lcmdlT2JqKHRvLCBmcm9tKSB7XHJcblx0Zm9yIChsZXQgcHJvcCBpbiBmcm9tKSB7XHJcblx0XHR0b1twcm9wXSA9IGZyb21bcHJvcF07XHJcblx0fVxyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gX2NzcyhlbCwgcHJvcCwgdmFsKSB7XHJcblx0bGV0IHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XHJcblxyXG5cdGlmIChzdHlsZSkge1xyXG5cdFx0aWYgKHZhbCA9PT0gdm9pZCAwKSB7XHJcblx0XHRcdGlmIChkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKSB7XHJcblx0XHRcdFx0dmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKGVsLmN1cnJlbnRTdHlsZSkge1xyXG5cdFx0XHRcdHZhbCA9IGVsLmN1cnJlbnRTdHlsZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHByb3AgPT09IHZvaWQgMCA/IHZhbCA6IHZhbFtwcm9wXTtcclxuXHRcdH1cclxuXHRcdGVsc2Uge1xyXG5cdFx0XHRpZiAoIShwcm9wIGluIHN0eWxlKSAmJiBwcm9wLmluZGV4T2YoJ3dlYmtpdCcpID09PSAtMSkge1xyXG5cdFx0XHRcdHByb3AgPSAnLXdlYmtpdC0nICsgcHJvcDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxubGV0IHJlcGFpbnQ7XHJcbmZ1bmN0aW9uIGFuaW1hdGUocHJldlJlY3QsIHRhcmdldCkge1xyXG5cdGxldCBtcyA9IG9wdGlvbnMuYW5pbWF0aW9uO1xyXG5cdGlmICh0YXJnZXQuYW5pbWF0ZWQpIHJldHVybjtcclxuXHJcblx0aWYgKG1zKSB7XHJcblx0XHRsZXQgY3VycmVudFJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0aWYgKHByZXZSZWN0Lm5vZGVUeXBlID09PSAxKSB7XHJcblx0XHRcdHByZXZSZWN0ID0gcHJldlJlY3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgYWN0dWFsbHkgbW92aW5nIHBvc2l0aW9uXHJcblx0XHRpZiAoKHByZXZSZWN0LmxlZnQgKyBwcmV2UmVjdC53aWR0aCAvIDIpICE9PSAoY3VycmVudFJlY3QubGVmdCArIGN1cnJlbnRSZWN0LndpZHRoIC8gMilcclxuXHRcdFx0fHwgKHByZXZSZWN0LnRvcCArIHByZXZSZWN0LmhlaWdodCAvIDIpICE9PSAoY3VycmVudFJlY3QudG9wICsgY3VycmVudFJlY3QuaGVpZ2h0IC8gMilcclxuXHRcdCkge1xyXG5cdFx0XHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnbm9uZScpO1xyXG5cdFx0XHRfY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJ1xyXG5cdFx0XHRcdCsgKHByZXZSZWN0LmxlZnQgLSBjdXJyZW50UmVjdC5sZWZ0KSArICdweCwnXHJcblx0XHRcdFx0KyAocHJldlJlY3QudG9wIC0gY3VycmVudFJlY3QudG9wKSArICdweCknXHJcblx0XHRcdCk7XHJcblx0XHRcdHJlcGFpbnQgPSB0YXJnZXQub2Zmc2V0V2lkdGg7XHJcblx0XHRcdF9jc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIG1zICsgJ21zJyk7XHJcblx0XHRcdF9jc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLDApJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0KHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInKSAmJiBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGVkKTtcclxuXHRcdHRhcmdldC5hbmltYXRlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRfY3NzKHRhcmdldCwgJ3RyYW5zaXRpb24nLCAnJyk7XHJcblx0XHRcdF9jc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xyXG5cdFx0XHR0YXJnZXQuYW5pbWF0ZWQgPSBmYWxzZTtcclxuXHRcdH0sIG1zKTtcclxuXHR9XHJcbn1cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xyXG4gICAgbGV0IGNvdW50ZXIgPSBhcnJheS5sZW5ndGggLSAxO1xyXG5cclxuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBlbGVtZW50cyBpbiB0aGUgYXJyYXlcclxuICAgIHdoaWxlIChjb3VudGVyID4gMCkge1xyXG4gICAgICAgIC8vIFBpY2sgYSByYW5kb20gaW5kZXhcclxuICAgICAgICBsZXQgaW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKTtcclxuXHJcbiAgICAgICAgLy8gRGVjcmVhc2UgY291bnRlciBieSAxXHJcbiAgICAgICAgY291bnRlci0tO1xyXG5cclxuICAgICAgICAvLyBBbmQgc3dhcCB0aGUgbGFzdCBlbGVtZW50IHdpdGggaXRcclxuICAgICAgICBsZXQgdGVtcCA9IGFycmF5W2NvdW50ZXJdO1xyXG4gICAgICAgIGFycmF5W2NvdW50ZXJdID0gYXJyYXlbaW5kZXhdO1xyXG4gICAgICAgIGFycmF5W2luZGV4XSA9IHRlbXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGFsaWduR3JpZDsiXSwic291cmNlUm9vdCI6IiJ9